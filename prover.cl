(defun two-pointer (knowledge-theorem index)
  (let ((t-backup (list)) (k-b-backup knowledge-theorem) (unifier (list)) (term-elem (list)) (term1-posi (list)) (term1-nega (list))
        (elem1-posi (list)) (elem1-nega (list)) (clause (list)))
    (progn
      (setq m 0)
      (while (< m (length k-b-backup))
        (setf mm (nth m k-b-backup))
        (print mm)
        (setf m (+ m 1)))
      (setq k 0)
      (setq index (- index 1))
      (while (< k index)
        (pop k-b-backup)
        (setq k (+ k 1)))
      (setf t-backup k-b-backup)
      (setf k-b-backup knowledge-theorem)
      (setq i 0)
      (while (< i (length t-backup))
        (setf term1 (nth i t-backup))
        (setq i (+ i 1))
        (setq j 0)
        (if (equal term1 nil)
            (progn
              (format t "~%Theorem can't be proven~%")
              (return-from two-pointer))
        (while (< j (length k-b-backup))
          (setf element1 (nth j k-b-backup))
          (setq j (+ j 1))
          (setq ii 0)
          (setq iii 0)
          (if (= (first element1) (first term1)) (return)
            (progn
              (while (< ii (length (second term1)))
                (setf term2 (nth ii (second term1)))
                (setq ii (+ ii 1))
                (setq jj 0)
                (while (< jj (length (third element1)))
                  (setf element2 (nth jj (third element1)))
                  (setf jj (+ jj 1))
                  (let ((nega (list)) (posi (list)))
                    (progn
                      (if (equal (first term2) (first element2))
                          (progn
                            (setf unifier (unify term2 element2))
                            (if (not (equal unifier nil))
                                (progn
                                  (setf term-elem (sublis unifier term2))
                                  (setf term1-posi (sublis unifier (second term1)))
                                  (setf term1-nega (sublis unifier (third term1)))
                                  (setf elem1-posi (sublis unifier (second element1)))
                                  (setf elem1-nega (sublis unifier (third element1)))
                                  (loop for term in term1-posi do
                                                (if (not(equal term-elem term))
                                                    (setf posi (append posi (list term)))))
                                  (setf posi (append posi elem1-posi))
                                  (loop for element in elem1-nega do
                                                (if (not(equal term-elem element))
                                                    (setf nega (append nega (list element)))))
                                  (setf nega (append nega term1-nega))
                                  (if (and (= (length posi) 1) (equal (first (first posi)) 'Answer) (equal nega nil))
                                      (progn
                                        (print (first posi))
                                        (format t "~%Answer was found!~%")
                                        (return-from two-pointer))
                                        (if(and (equal posi nil) (equal nega nil)) 
                                              (progn
                                                (setf clause (list (first element1) '+ (first term1) '= 'false))
                                                (print clause)
                                                (format t "~%Theorem was successfully proven!~%")
                                                (return-from two-pointer))
                                            (progn
                                              (setf clause (list (+ (length k-b-backup) 1) posi nega (first element1) '+ (first term1)))
                                              (setq iiii 0)
                                              (setq jjjj 0)
                                              (while(< iiii (length k-b-backup))
                                                (setf element3 (nth iiii k-b-backup))
                                                (setq iiii (+ iiii 1))
                                                (if(dupe element3 clause)
                                                    (progn 
                                                      (setq jjjj 1) 
                                                      (return))))
                                              (if (not (= jjjj 1))
                                                  (progn
                                              (setf k-b-backup (append k-b-backup (list clause)))
                                              (setf t-backup (append t-backup (list clause)))
                                              (print clause))))))))))))))
               (while (< iii (length (third term1)))
                (setf term2 (nth iii (third term1)))
                (setq iii (+ iii 1))
                (setq jjj 0)
                (while (< jjj (length (second element1)))
                  (setf element2 (nth jjj (second element1)))
                  (setf jjj (+ jjj 1))
                  (let ((nega (list)) (posi (list)))
                    (progn
                      (if (equal (first term2) (first element2))
                          (progn
                            (setf unifier (unify term2 element2))
                            (if (not (equal unifier nil))
                                (progn
                                  (setf term-elem (sublis unifier term2))
                                  (setf term1-posi (sublis unifier (second term1)))
                                  (setf term1-nega (sublis unifier (third term1)))
                                  (setf elem1-posi (sublis unifier (second element1)))
                                  (setf elem1-nega (sublis unifier (third element1)))
                                  (loop for term in term1-nega do
                                                (if (not(equal term-elem term))
                                                    (setf nega (append nega (list term)))))
                                  (setf nega (append nega elem1-nega))
                                  (loop for element in elem1-posi do
                                                (if (not(equal term-elem element))
                                                    (setf posi (append posi (list element)))))
                                  (setf posi (append posi term1-posi))
                                  (if (and (= (length posi) 1) (equal (first (first posi)) 'Answer) (equal nega nil))
                                      (progn
                                        (print (first posi))
                                        (format t "~%Answer was found!~%")
                                        (return-from two-pointer))
                                      (if(and (equal posi nil) (equal nega nil)) 
                                              (progn
                                                (setf clause (list (first element1) '+ (first term1) '= 'false))
                                                (print clause)
                                                (format t "~%Theorem was successfully proven!~%")
                                                (return-from two-pointer))
                                            (progn
                                              (setf clause (list (+ (length k-b-backup) 1) posi nega (first element1) '+ (first term1)))
                                              (setq iiii 0)
                                              (setq jjjj 0)
                                              (while(< iiii (length k-b-backup))
                                                (setf element3 (nth iiii k-b-backup))
                                                (setq iiii (+ iiii 1))
                                                (if(dupe element3 clause) 
                                                    (progn 
                                                      (setq jjjj 1) 
                                                      (return))))
                                              (if (not (= jjjj 1))
                                                  (progn
                                              (setf k-b-backup (append k-b-backup (list clause)))
                                              (setf t-backup (append t-backup (list clause)))
                                              (print clause)))))))))))))))))))
      (format t "~%Theorem can't be proven~%")))) 

(defun unit-preference (knowledge-theorem index)
  (let ((t-backup knowledge-theorem) (k-b-backup (list)) (unifier (list)) (term-elem (list)) (term1-posi (list)) (term1-nega (list))
        (elem1-posi (list)) (elem1-nega (list)) (clause (list)))
    (progn
      (setq m 0)
      (while (< m (length t-backup))
        (setf mm (nth m t-backup))
        (print mm)
        (setf m (+ m 1)))
      (setq k 0)
      (setq index (- index 1))
      (while(< k index)
        (setq k-b-backup (append k-b-backup (list (pop t-backup))))
        (setq k (+ k 1)))
      (setq t-backup (sort-theorem t-backup))
      (while (not (equal t-backup nil))
        (setf term1 (first t-backup))
        (setq j 0)
        (while (< j (length k-b-backup))
          (setf element1 (nth j k-b-backup))
          (setq j (+ j 1))
          (setq ii 0)
          (setq iii 0)
          (while (< ii (length (second term1)))
                (setf term2 (nth ii (second term1)))
                (setq ii (+ ii 1))
                (setq jj 0)
                (while (< jj (length (third element1)))
                  (setf element2 (nth jj (third element1)))
                  (setf jj (+ jj 1))
                  (let ((nega (list)) (posi (list)))
                    (progn
                      (if (equal (first term2) (first element2))
                          (progn
                            (setf unifier (unify term2 element2))
                            (if (not (equal unifier nil))
                                (progn
                                  (setf term-elem (sublis unifier term2))
                                  (setf term1-posi (sublis unifier (second term1)))
                                  (setf term1-nega (sublis unifier (third term1)))
                                  (setf elem1-posi (sublis unifier (second element1)))
                                  (setf elem1-nega (sublis unifier (third element1)))
                                  (loop for term in term1-posi do
                                                (if (not(equal term-elem term))
                                                    (setf posi (append posi (list term)))))
                                  (setf posi (append posi elem1-posi))
                                  (loop for element in elem1-nega do
                                                (if (not(equal term-elem element))
                                                    (setf nega (append nega (list element)))))
                                  (setf nega (append nega term1-nega))
                                  (if (and (= (length posi) 1) (equal (first (first posi)) 'Answer) (equal nega nil))
                                      (progn
                                        (print (first posi))
                                        (format t "~%Answer was found!~%")
                                        (return-from unit-preference))
                                          (if(and (equal posi nil) (equal nega nil)) 
                                              (progn
                                                (setf clause (list (first element1) '+ (first term1) '= 'false))
                                                (print clause)
                                                (format t "~%Theorem was successfully proven!~%")
                                                (return-from unit-preference))
                                            (progn
                                              (setf clause (list (+ (+ (length k-b-backup) (length t-backup)) 1) posi nega (first element1) '+ (first term1)))
                                              (setq iiii 0)
                                              (setq jjjj 0)
                                              (setq k-total (append k-b-backup t-backup))
                                              (while(< iiii (length k-total))
                                                (setf element3 (nth iiii k-total))
                                                (setq iiii (+ iiii 1))
                                                (if(dupe element3 clause)
                                                    (progn 
                                                      (setq jjjj 1) 
                                                      (return))))
                                              (if (not (= jjjj 1))
                                                  (progn
                                              (setf t-backup (append t-backup (list clause)))
                                              (print clause))))))))))))))
               (while (< iii (length (third term1)))
                (setf term2 (nth iii (third term1)))
                (setq iii (+ iii 1))
                (setq jjj 0)
                (while (< jjj (length (second element1)))
                  (setf element2 (nth jjj (second element1)))
                  (setf jjj (+ jjj 1))
                  (let ((nega (list)) (posi (list)))
                    (progn
                      (if (equal (first term2) (first element2))
                          (progn
                            (setf unifier (unify term2 element2))
                            (if (not (equal unifier nil))
                                (progn
                                  (setf term-elem (sublis unifier term2))
                                  (setf term1-posi (sublis unifier (second term1)))
                                  (setf term1-nega (sublis unifier (third term1)))
                                  (setf elem1-posi (sublis unifier (second element1)))
                                  (setf elem1-nega (sublis unifier (third element1)))
                                  (loop for term in term1-nega do
                                                (if (not(equal term-elem term))
                                                    (setf nega (append nega (list term)))))
                                  (setf nega (append nega elem1-nega))
                                  (loop for element in elem1-posi do
                                                (if (not(equal term-elem element))
                                                    (setf posi (append posi (list element)))))
                                  (setf posi (append posi term1-posi))
                                  (if (and (= (length posi) 1) (equal (first (first posi)) 'Answer) (equal nega nil))
                                      (progn
                                        (print (first posi))
                                        (format t "~%Answer was found!~%")
                                        (return-from unit-preference))
                                          (if(and (equal posi nil) (equal nega nil)) 
                                              (progn
                                                (setf clause (list (first element1) '+ (first term1) '= 'false))
                                                (print clause)
                                                (format t "~%Theorem was successfully proven!~%")
                                                (return-from unit-preference))
                                            (progn
                                              (setf clause (list (+ (+ (length k-b-backup) (length t-backup)) 1) posi nega (first element1) '+ (first term1)))
                                              (setq iiii 0)
                                              (setq jjjj 0)
                                              (setq k-total (append k-b-backup t-backup))
                                              (while(< iiii (length k-total))
                                                (setf element3 (nth iiii k-total))
                                                (setq iiii (+ iiii 1))
                                                (if(dupe element3 clause) 
                                                    (progn 
                                                      (setq jjjj 1) 
                                                      (return))))
                                              (if (not (= jjjj 1))
                                                  (progn
                                              (setf t-backup (append t-backup (list clause)))
                                                    (print clause)))))))))))))))
        (setq k-b-backup (append k-b-backup (list (pop t-backup))))
        (setq t-backup (sort-theorem t-backup))
        )
    (format t "~%Theorem can't be proven~%"))))     